# 메모리 관리 (Management Memory)

> 메모리란?

  모든 프로그램은 우선 메모리에 적재되어야 실행이 가능하므로 메모리는 프로그램을 실행하는 중요한 작업 공간입니다. 그리고 다중 프로그래밍 환경에서는 한정된 메모리를 여러 프로세스가 함께 사용하므로 이를 효율적으로 관리하는 방법이 필요하다.

> 메모리 관리란?

  * 프로세스들을 위해 메모리를 할당하고 제거하며 보호하는 활동이다
  * 메모리 관리자의 예약된 메모리 할당
  * 운영체제가 동적으로 메모리를 세분화
  * 메모리 관리자가 담당하며, 메모리 관리 장치(Memory management unit)가 협업하여 관리한다.

> 메모리 관리 주요 정책

  * 적재 정책

    적재 정책은 디스크에서 메모리로 프로세스를 반입할 시기를 결정하는 것이다.

    * 요구 적재 : 다음에 실행할 프로세스를 메모리에 적재하는 오래된 방법
    * 예상 적재 : 시스템의 요청을 미리 예측하여 메모리에 적재하는 방법

  * 배치 정책

    디스크에서 반입한 프로세스를 메모리 어느 위치에 저아할 것인지 결정한다. 최초 적합, 최적 적합, 최악 적합이 있다.
   
    * 대치 정책 : 메모리가 충분하지 않을 때 현재 메모리에 적재된 프로세스 중 제거할 프로세스를 결정하는 교체 방법이다. 선입선출, 최근 최소사용, 대치 알고리즘 등이 있다.

### 단어 정리

> 논리적 주소

  * 프로그래머가 프로그래밍에 사용하는 공간으로 보는 논리적 관점의 주소
  * 논리적 주소는 가상 주소라고도 하는데, 목적 코드가 저장된 공간과 프로그램에서 사용하는 자료구조 등이 이에 해당한다.


> 물리적 주소

  * 실제 데이터나 프로그램을 저장하는 공간으로 보는 물리적 관의 주소
  * 논리적 주소에 대응하여 적재하는 실제 주소로, 메모리 칩이나 디스크 공간에서 만든다.

> MMU(Memory Management Unit)

  * 논리적 주소와 물리적 주소의 변환을 처리하는 역할을 한다.
  * 고정 분할, 동적 분할, 페이징, 세그먼테이션, 페이지화된 세그먼테이션등 변환 방법을 사용할 수 있다.

> 바인딩(binding)

  * 논리적 주소에 대응하는 물리적 주소를 알아야 프로세서가 프로세스를 실행할 수 있는데, 이 두 주소를 연결, 즉 매핑(mapping)시켜 주는 작업을 바인딩이라고 한다.

> 동적 적재(dynamic loading)

  * 모든 루틴을 메모리에 적재하지 않고, 교체 가능한 형태로 디스크에 저장한다.
  * 메인 프로그램만 먼저 메모리에 적재하여 수행한다.
  * 사용하지 않을 루틴을 메모리에 적재하지 않으므로 메모리를 효율적으로 사용할 수 있다.

> 중첩(overlay)

  * 운영체제 영역과 메모리의 일부 영역에는 프로그램 실행에 꼭 필요한 명령어와 데이터만 저장한다.
  * 나머지 중첩 영역에는 필요할 때 호출하여 적재하는 방법이 있다.

> 스와핑(Swapping)

  * 스왑 아웃 : 프로세서 할당이 끝나고 수행이 완료된 프로세스는 보조기억장치로 보내는 것
  * 스왑 인 : 새롭게 시작하는 프로세스는 메모리에 적재하는 것
  
  
### 메모리 적재 

> 연속 메모리 적재 방법

  * 초기 컴퓨터 시스템에서 사용이 되었다.
  * 직접배치, 중첩, 고정 분할 방법 등이 해당한다.
  * 크기가 다른 프로세스에 모두 같은 크기의 메모리를 할당하여 메모리 낭비를 초래함.
  * 내부 또는 외부 단편화 문제가 발생할 수 있다. 


> 비연속(분산) 메모리 적재 방법

  * 외부 단편화를 해결하고, 내부 단편화를 최소화하려고 소개한 새로운 방법이다.
  * 프로그램 하나가 물리적 주소의 여러 공간에서 분산해서 올라갈 수 있도록 하는 방법이다.
  
  * 고정 분할 방법
 
    * 논리적 주소가 분할된 메모리보다 크면 오류가 발생하고, 작으면 내부 단편화가 발생한다.
  
    * 페이징 : 프로그램 하나를 분할하는 기준에 따라 동일한 크기로 나눠 메모리로 적재하는 방법
    * 세그먼테이션 : 크기는 일정하지 않지만 의미 단위로 나눠 메모리로 적재하는 방법.

  * 가변 분할 방법

    * 고정된 경계를 없애고 각 프로세스가 필요한 만큼 메모리를 할당하는 것
    * 외부 단편화가 발생한다.
    
    * 최초 적합(First-fit) : 프로세스를 사용 가능 공간 중 충분히 큰 첫 번째 공간에 할당한다. 공간활용률이 떨어지는 단점이 존재.
    * 최적 적합(Best-fit) : 프로세스를 충분히 큰 사용 가능 공간 중에서 들어갈 수 있는 가장 작은 공간에 할당한다. 할당 과정에 많은 시간이 소요될 수 있다.
    * 최악 적합(Worst-fit) : 프로세스를 가장 큰 사용 가능 공간에 할당한다. 

### 단편화(Fragmentation)
    
> 외부 단편화(External Fragmentation)

  총 공간을 계산해 봤을 때 요청을 만족할 충분한 메모리가 있음에도 가능한 공간이 연속적이지 않아서 외부 단편화가 발생합니다.

> 내부 단편화(Internal Fragmentation)

  프로세스를 일정 크기인 페이지로 잘라서 메모리에 적재를 시켰지만 정확히 나누어 떨어지지 않을 때를 내부 단편화라고 합니다.
  논리 주소를 동일한 크기로 자르고 물리 주소도 이와 동일하게 자르게 되면서 나타나는 단편화.
  
  
  
### 페이징(Paging)

  내부 단편화가 발생할 수 있으나, 메모리를 효율적으로 사용할 수 있고 작업 크기가 동일하여 다양한 알고리즘을 개발할 수 있다.

> 페이징이란?

  작업을 크기가 동일한 페이지로 나눠 처리하는 방법이다. 프로세스를 크기가 동일한 페이지로 나누고, 메인 메모리도 프레임이라는 고정 크기 블록으로 나눠 이 프레임에 페이지를 적재하는 방법이다.
  물리적 주소 없이도 큰 가상 주소 공간이 가능하게 하려고 등장했다.
  
> 페이징 시스템 사용 방법

  * 프로세스에 필요한 페이지를 결정하여 페이지 번호를 부여한다.
    *   
  
  * 메모리의 빈 프레임을 조사하여 프로세스를 적재할 위치를 파악한다.
    * 
  
  * 프로세스의 페이지를 빈 프레임에 적재하도록 준비한다.

    * 빈 프레임에 어떤 페이지든 적재할 수 있어 메모리를 효율적으로 사용할 수 있고, 프레임 간에 외부 단편화도 발생하지 않는다.
    * 한 프로세스 페이지를 메인 메모리의 여러 위치에 분산 적재하여 운영체제의 페이지 관리 부담이 크다.
    * 마지막 페이지에 할당된 프레임이 완전히 차지 않아 내부 단편화(Internal Fragmentation)이 발새한다. 최악의 경우 n+1개가 생성된다.

> 페이지 테이블(Page Table)

  논리적 주소를 물리적 주소로 변환하는데, 페이지 테이블은 페이지의 논리적 주소인 페이지 번호와 이에 대응하는 물리적 주소인 페이지 프레임 주소를 포함한다.

### 세그먼테이션(Segmentation)

  세그먼테이션은 프로세스 관점을 지원하여 메모리를 크기가 변할 수 있는 세그먼트로 나눈다. 각 세그먼트는 연관된 기능을 수행하는 하나의 모듈 프로그램으로 생각하며, 메모리의 연속된 위치에서 구성하되 서로 인접할 필요는 없다.
  프로그램과 데이터를 논리적으로 독립된 주소 공간으로 나누고 쉽게 공유 보호 할수 있게 하려고 등장했다.
  외부 단편화가 발생할 수 있으나, 가변적인 데이터 구조와 모듍처리, 공유와 보호의 지원이 편리하다.
  
  * 메모리의 사용자 관점을 지원하는 비연속 메모리 할당 방법, 논리적 영역을 세그먼트의 집합으로 인식한다.
  * 프로세스에 따라 세그먼트 크기가 달라 메모리를 크기가 일정한 페이지 프레임으로 나누지 않고 동적 분할(가변 분할) 방법으로 할당한다.





















    
