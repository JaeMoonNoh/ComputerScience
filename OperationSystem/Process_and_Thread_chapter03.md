# Process and Thread


![Process_thread_PCB](https://user-images.githubusercontent.com/62277037/144992334-325fa421-dd64-4f40-a12d-6cbd67d15a1d.PNG)


## Process

* 실행 중인 프로그램 (일반적인 정의) -> 디스크에 있던 프로그램을 메모리에 적재하여 운영체제의 제어를 받는 상태가 되었다. -> 자신만의 메모리 영역이 있음을 의미함
* 비동기적(asynchronous)행위
* 실행 중인 프로시저
* 실행중인 프로시저의 제어 추적
* 운영체제에 들어 있는 프로세스 제어 블록(PCB)
* 프로세서에 할당하여 실행할 수 있는 개체 디스패치가 가능한 대상

프로그램이란 컴파일한 코드와 초기화 전역변수, 문자열과 문자열 상수 등 정적 데이터를 포함하는 정적인 개체이다.
반면에 프로세스는 (스택,힙,데이터,코드) 메모리 구조를 이루고, 프로그램 카운터나 레지스터처럼 현재 어떤 자원을 사용하는지 관련 정보가 들어 있는 동적인 개체이다.

* Stack : 데이터를 일시적으로 저장하는 영역이다. 지역 변수에 사용한다. 보통 힙과 인접한 방향으로 점점 커져 스택 포인터와 힙 포인터를 만나면 메모리가 소진 되었다는 뜻이다.
* Heap : 코드 영역과는 별도로 유지되는 자유 영역이다. 동적으로 메모리를 할당하려고 프로그램 실행 중 시스템 호출을 사용했다가 해제하는 방법으로 활용한다.
* Data : 전역변수나 정적변수를 저장하거나 할당하고 실행하기 전에 초기화 한다.
* Code : 프로그램을 시작할 때 프로세서가 디스크에서 읽어 실행하는 컴파일한 프로그램을 저장한다.

## 프로세스의 상태 변화

프로세스는 시스템에서 준비, 실행, 대기 상태로 바뀌면서 실행하고 종료하는데, 시스템을 떠날 때까지 이 과정을 반복합니다.

![process_context](https://user-images.githubusercontent.com/62277037/144994545-81c6a0e2-a5d1-483a-bee9-260fd7bafde6.PNG)
[프로세스의 상태변화 그림]

* Dispatch(준비 -> 실행) : 준비 큐 맨 앞에 있던 프로세스가 프로세서를 점유하는 것을 디스패치라고 한다. [Scheduler Dispatch ]
* TimeOut(실행 -> 준비) : 실행 상태의 프로세스가 프로세서를 계속 독점하지 않도록 인터럽트 클록을 두어 특정 프로세스가 할당된 시간 동안만 프로세서를 점유하게 된다. [Interrupt]
* Block(실행 -> 대기) : 프로세스에 입출력 연산 등이 필요하거나 새로운 자원 요청 등의 문제로 프로세서를 스스로 양도하면 대기 상태가 된다. [I/O Event Wait]
* Wake up(대기 -> 준비) : 프로세스는 입출력 작업이 끄나면 깨움으로 대기에서 준비 상태가 된다. [I/O Event Complete]

## Interrupt

예기치 못한 상황이 발생, 현재 실행중인 작업을 즉시 중단한다. 발생된 상항에 대한 우선 처리가 필요함을 CPU에 알립니다.
* 외부 : I/O 장치, 타이밍 장치, 전원 등 외부적 요인으로 발생
* 내부 : Trap, 잘못된 명령이나 데이터 사용시 발생(0으로 나누기, overflow)

## Polling

사용자가 명령어를 사용해 입력 핀의 값을 계속 읽어 변화를 체크하는 것 -> 인터럽트 요청 플래그를 차례로 비교하여 우선순위가 가장 높은 인터럽트 자원을 찾아 이에 맞는 인터럽트 서비스 루틴을 수행한다.

## PCB(Process Control Block)

![PCB](https://user-images.githubusercontent.com/62277037/143189368-7facc539-2f05-4875-9417-f11e4e427e6a.PNG)


프로세스가 생성되면 메모리에 프로세스 제어 블록을 생성하고, 프로세스가 실행을 종료하면 해당 프로세스 제어 블록도 삭제한다.
* Pointer : 준비, 대기상태의 queue 구현
* Process State : 현 process의 상태
* Process Number : 고유번호

## Context Switching

* Distpatch, TimeOut, Block에서 발생한다.
* 이전 프로세스의 상태 레지스터 내용을 보관하고 다른 프로세스의 레지스터를 적재하여 프로세스를 교환하는 과정이다.
* 인터럽트나 시스템 호출 등으로 실행 중인 프로세스의 제어를 다른 프로세스에 넘겨 실행 상태가 되도록 하는 것을 프로세스 문맥교환(Context Switching)이라고 한다.
* 문맥교환이 일어나면 프로세서의 레지스터에 있던 내용을 나중에 사용할 수 있도록 저장한다.

* 실행중인 프로세스에 인터럽트가 발생하면 운영체제가 다른 프로세스를 실행 상태로 바꾸고 제어를 넘겨주어 프로세스 문맥교환이 일어난다.
* 인터럽트는 인터럽트 처리 루틴을 실행한 후 현재 실행 중인 프로세스를 재실행할 수 있으므로 인터럽트가 곧 프로세스 문맥 교환으로 발전하지는 않는다.
* 트랩은 부적절한 파일 접근이나 현재 실행중인 프로세스 오류나 예외 상황으로 발생할 수 있다.

## Thread

프로세스는 두 가지 특성인 자원과 제어로 구분할 수 있습니다.
* 제어만 분리한 실행 단위를 스레드라고 한다.
* 스레드들은 프로세스의 직접 실행 정보를 제외한 나머지 프로세스 관리 정보를 공유한다.
* 프로그램 카운터와 스택 포인터 등을 비롯한 스레드 실행 환경 정보, 지역 데이터, 스택을 독립적으로 가지면서 코드, 전역 데이터, 힙을 다른 스레드와 공유한다.
* 스레드는 관련 자원과 함께 메모리를 공유할 수 있는데, 이 때문에 손상된 데이터나 스레드의 이상 동작을 고려해야 한다.

## Thread 장점

* 사용자 응답성 증가 : 병렬 프로그램으로 프로그램을 계속 실행할 수 있어 사용자 응답성이 증가한다. 스레드 한 개가 파일을 로딩하는 동안 다른 스레드는 사용자와 상호작용을 할 수 있다.
* 프로세스의 자원과 메모리 공유 가능 : 응용 프로그램 하나가 동일한 주소 공간에서 스레드를 여러 개 실행하여 시스템 성능을 향상시킬 수 있다.
* 경제성이 좋다 : 프로세스를 생성하는 것보다 스레드를 생성하여 문맥을 교환하면 오버헤드가 줄어든다.
* 다중처리로 성능과 효율 향상 : 각 스레드를 여러 프로세서에서 병렬로 실행하여 성능과 효율성을 높일 수 있다.


### 간략하고 날것으로 전문적인 말 없이 정리

흐름을 얘기해 보자면, 프로그램을 더블 클릭 했을때 프로세스가 생성되고 프로세스 진행과정을 거쳐 Run의 위치로 가있는다.
계속해서 프로그램이 실행중인 와중에 갑자기 프린트를 해야하는 상황이 발생했다(I/O Event)가 발생하면서 실행중이던 프로세스는 잠시 Wait단계로 가있다가 프린트가 완료가 되면 Ready에서
CPU사용 기회를 엿보다가 다시 본인 차례가 온다면(Scheduler Dispatch) Run으로 들어가 실행한다. 대충 이렇게 이해를 하면 될것같다.

다음에 다시 작성할 예정.
